<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>作用域和闭包</title>
</head>
<body>
<ul>
    <li>列表一</li>
    <li>列表二</li>
    <li>列表三</li>
    <li>列表四</li>
    <li>列表五</li>
</ul>
<script>
    /*
     * 当一个方法在运行的时候，就会形成一个私有的作用域，
     * 在这个作用域里，里面定义的变量不会受到上一级作用域或其它作用域的影响，不会和全局或其它作用域里的变量有冲突。
     * 这个由方法运行而产生的私有作用域，就叫闭包。
     * 我们应该把闭包理解为函数运行机制，而不是某种形式。
     * 预解释的代码不会受到return的影响。
     * */
    /*
    * 函数的运行是个有生命周期的内存地址
    * 或者说：函数运行时，会创建一个内存地址，当此函数结束时，此内存地址有会销毁。这个地址，我们无法保存，它是灵活的、活动的、有生命周期的。
    * 函数里的变量，就在这个内存里面创建，我们可以把这个内存当成一个对象，那函数里的变量就是这个对象的属性
    * 严重理解函数的定义和函数的运行
    * */

    /*闭包其实就是函数在运行的时候产生的那个私有作用域。*/
    /*闭包的作用说的更直白一些就是为了让变量更安全，让一个环境中的变量与其它环境中的变量隔离开不产生冲突。*/
        /*var name='china';
        var age=5000;
        //定义一个匿名函数再让这个匿名函数运行，并给匿名函数传参数
        (function(chinaName,chinaAge){	//这里是给匿名方法定义的形式参数
            var name='珠峰培训'
            var  age=4;
            alert(chinaName+'有'+chinaAge+'多的历史了。'+name+'有'+age+'多的历史了。');
        })(name,age);	//这里是给匿名方法传的参数*/

    /*在这个例子里，定义了两个全局变量name和age，在下面的匿名函数里也定义了变量name和age,但这两组相同的变量互不影响，匿名方法里的变量属于自己的私有的作用域，这个运行的匿名方法就形成了闭包。如果在这个匿名方法想用到全局变量name和age,可以通过传参数的方式传给这个匿名函数。
     上面这种写法和下面的代码同效（只不过一个是匿名函数一个是有名函数而已）：*/
    /*var name='china';
    var age=5000;
    function fn(chinaName,chinaAge){    //给刚才的匿名函数起了个名字叫fn
        var name='珠峰培训'
        var age=4;
        alert(chinaName+'有'+chinaAge+'多的历史了。'+name+'有'+age+'多的历史了。');
    }
    fn(name,age); //让函数运行*/


    //    定义在闭包里的变量和函数在全局下是不能使用的。那我们怎么能让定义在闭包里的函数能在闭包外面使用呢？方法很简单，就是把它赋值给一个全局变量，如下例：
    /*(function(chinaName,chinaAge){
        var name='珠峰培训'
        var age=4;
        function speciality(){//这个函数是私有，外部不能访问。这就形成了一个闭包方法
            alert(name+'的特长是javaScript培训,已经 做了'+age+'年多了');
        }
        //如果把这个函数赋给window的zhufengpeixun这个属性，就相当于多了一个全局函数zhufengpeixun，那我们就可以在外部调用zhufengpeixun这个函数了，其实就是调用speciality这个函数
        window.zhufengpeixun=speciality;
    })();
    zhufengpeixun(); //运行这个方法，弹出：珠峰培训的特长是javaScript培训,已经做了4年多了*/
    //    zhufengpeixun这个方法是在闭包里定义的，并且这个方法里用到的变量也是闭包内部的私有变量，不会和其它作用域下的变量冲突，相对来说是比较安全的。





    /*    关于闭包和作用域
     请听题：请分别说出下面 a b c d的值*/
    /*function fo(){
     var i=0;
     return function(n){
            return n+i++;
        }
     };

     var f=fo();*/

    /*var b1=fo()(15);
     var b2=15,
     b2=b2++;
     var b3= 0;
     console.log(b1);
     console.log(b2);
     console.log(b3++);

     for(var i=0;i<10;i++){

     }
     研究i++和++i的原理:
     i++,是执行完后面的语句才加1。a=i++,相当于a=i;i=i+1;（先使用i的值,再i=i+1）。
     ++i,是先i+1才执行后面的语句。a=++i，相当于i=i+1;a=i;（先i=i+1,再使用i的值）。
     */

    /*var a = f(15); //value:15
    var b = fo()(15); //value:15
    var c = fo()(20); //value:20
    var d = f(20); //value:21

    console.log('a:'+a+';')
    console.log('b:'+b+';')
    console.log('c:'+c+';')
    console.log('d:'+d+';')*/


    /*分析：
     在fo这个函数里，定义了一个内部方法，这是个闭包方法，它在fo运行的这个作用域里活动。当fo运行时，会将其返回。
     每运行一次，就会创建这样一个方法，并将其返回。
     fo()(15)的意思就是fo先运行，运行后返回一个函数，再在这个返回的函数后边加括号，就是再让这个返回的函数运行。
     后边括号里的15，就是传给里面那个匿名函数的实参，这个函数将15和fo这个作用域里定义的i先累加，然后i再自加1，就是n+i++(i++意思是i=i+1，因为先使用i的值，所以i的值是0)的意思，所以就是15+0，所以fo()(15)返回的值是15。
     fo()运行完了，释放作用域。

     看b和c，函数fo每运行一次，里面的变量i和那个匿名函数就会被创建一次，fo()(15)和fo()(20)是相当于fo分别被运行了两次，创建了两个不同的作用域，
     这两个作用域里的变量或值是不会有任何关系的，并且这两次运行，完成之后这个作用就销毁了。

     a和d是都是在执行f这个函数，f是同一次fo执行时的返回值，
     也就是说，当fo这时候运行的时候，fo这个作用域里定义的这个函数（函数也是数据），被全局变量f给占用了，那么这次fo函数运行产生的这个作用域，就不能被销毁了。
     f第一次运行的时候，返回了15，把这个作用域里的i变成了1，当第二次f再运行的时候，就是20和1相加了，所以是21。当20和1相加之后，i再累加，则i就是就是2了。
     这时候这个作用域还是释放不掉，因为f是全局变量。如果这会写一个f=null，则就能把这个作用域释放掉了。


     所以正确答案是：a是15，b是15，c是20，d是21。*/



    /*最后以一道综合面试作为本讲的结尾吧，如果您能非常顺利的把答案说正确，并且真正理解代码的运行过程，那您在闭包，作用域，预解释，this关键字这方面的知识，就过关了。请听题：（用本山大叔的口音）*/
    var number = 2;//全局number，定义了window.number=2
    var obj = {
        number: 4,//obj的属性number，定义了obj.number=4
        fn1: (function () {
            this.number *= 2;//自运行函数的this就是window，全局的number就是4了
            number = number * 2;//注意这是个坑，可以console.log(number)一下；
            var number = 3;//注意这儿的number是被预解释的
            return function () {
                this.number *= 2;//this是谁，这会不知道，运行的时候再知道
                number *= 3;//number肯定是上一级作用域里的。即：变量值是什么，由在那儿的定义决定。
                alert(number);//每次运行这个函数，会弹出什么来
            }//这个匿名方法返回这个函数，fn1最终就是这个函数。
        })(),//这个匿名函数运行就是一个闭包
        db2: function () {
            this.number *= 2
        }
    };

    var fn1 = obj.fn1;//obj.fn1这个属性就保存了（匿名函数返回的那个函数的地址），则在132定义的函数就不能被销毁了，这个函数是在闭包里定义的。这个函数不能被销毁
    alert(number);//问这会会弹出什么结果 4（第133行）
    fn1();//这会弹出什么结果 9（第137行，全局number已经是8；第138、139行，并且弹出9）
    obj.fn1();//这次弹出什么结果 27（obj的number为8，alert的number为9*3=27）

    alert(window.number); //这会window.number的结果是什么 8
    alert(obj.number);   //这会obj.number的结果是什么 8
    /*提示：this表示的是谁，和定义在那儿没有关系，只和运行在那儿有关系。变量的值用那个，和运行在那儿没关系，只和定义在那儿有关系。（好绕啊！！）*/
    /*注意：题目中有三个number要分清：
    * 1、全局的number;2、obj的属性number;3、匿名方法运行的那个闭包里的number，下面132行。135行的number就是132行定义的number
    * */
</script>
</body>
</html>