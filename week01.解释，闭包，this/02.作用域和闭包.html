<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>作用域和闭包</title>
</head>
<body>
<ul>
    <li>列表一</li>
    <li>列表二</li>
    <li>列表三</li>
    <li>列表四</li>
    <li>列表五</li>
</ul>
<script>
    /*
     * 当一个方法在运行的时候，就会形成一个私有的作用域，
     * 在这个作用域里，里面定义的变量不会受到上一级作用域或其它作用域的影响，不会和全局或其它作用域里的变量有冲突。
     * 这个由方法运行而产生的私有作用域，就叫闭包。
     * 我们应该把闭包理解为函数运行机制，而不是某种形式。
     * 预解释的代码不会受到return的影响。
     * */

    /*闭包其实就是函数在运行的时候产生的那个私有作用域。*/
    /*闭包的作用说的更直白一些就是为了让变量更安全，让一个环境中的变量与其它环境中的变量隔离开不产生冲突。*/
    //    var name='china';
    //    var age=5000;
    //    //定义一个匿名函数再让这个匿名函数运行，并给匿名函数传参数
    //    (function(chinaName,chinaAge){	//这里是给匿名方法定义的形式参数
    //        var name='珠峰培训'
    //        var  age=4;
    //        alert(chinaName+'有'+chinaAge+'多的历史了。'+name+'有'+age+'多的历史了。');
    //    })(name,age);	//这里是给匿名方法传的参数

    /*在这个例子里，定义了两个全局变量name和age，在下面的匿名函数里也定义了变量name和age,但这两组相同的变量互不影响，匿名方法里的变量属于自己的私有的作用域，这个运行的匿名方法就形成了闭包。如果在这个匿名方法想用到全局变量name和age,可以通过传参数的方式传给这个匿名函数。
     上面这种写法和下面的代码同效（只不过一个是匿名函数一个是有名函数而已）：*/
    //    function fn(chinaName,chinaAge){    //给刚才的匿名函数起了个名字叫fn
    //        var name='珠峰培训'
    //        var age=4;
    //        alert(chinaName+'有'+chinaAge+'多的历史了。'+name+'有'+age+'多的历史了。');
    //    }
    //    fn(name,age); //让函数运行


//    定义在闭包里的变量和函数在全局下是不能使用的。那我们怎么能让定义在闭包里的函数能在闭包外面使用呢？方法很简单，就是把它赋值给一个全局变量，如下例：
//    (function(chinaName,chinaAge){
//        var name='珠峰培训'
//        var age=4;
//        function speciality(){//这个函数是私有，外部不能访问。这就形成了一个闭包方法
//            alert(name+'的特长是javaScript培训,已经 做了'+age+'年多了');
//        }
//        //如果把这个函数赋给window的zhufengpeixun这个属性，就相当于多了一个全局函数zhufengpeixun，那我们就可以在外部调用zhufengpeixun这个函数了，其实就是调用speciality这个函数
//        window.zhufengpeixun=speciality;
//    })();
//    zhufengpeixun(); //运行这个方法，弹出：珠峰培训的特长是javaScript培训,已经做了4年多了
//    zhufengpeixun这个方法是在闭包里定义的，并且这个方法里用到的变量也是闭包内部的私有变量，不会和其它作用域下的变量冲突，相对来说是比较安全的。

//    function fn() {
//        var n = 9;
//    }
//    fn();
//    fn();
//    alert(n);
//    (function fn() {
//        var n = 9;
//    })();

    /*    再看一个具体的应用实例：
     有如下html代码，要求：点击下面的li，会弹出对应的索引号。
     <ul>
     <li>列表一</li>
     <li>列表二</li>
     <li>列表三</li>
     <li>列表四</li>
     <li>列表五</li>
     </ul>
     很多人给出了如下错误的代码（点击li时弹出的是5）：*/
    /*var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        oLis [i].onclick = function () {//注意：这里的这个匿名方法，在循环运行的时候这个匿名方法本身并不运行，当点击某个li的时候，这个方法才运行呢。
//事件绑定相当于做计划，当点击的时候才相当于执行计划，请参考第一天教材的事件绑定部分的描述
            alert(i);//这里的这个i不是在这个匿名方法里定义的，而是上一级作用域里定义的。当这句代码运行的时候，循环早已经结束，并且i已经等于oLis.length了。
//            这里的问题出在这个方法里用到的是上一级作用域里定义的变量，如果要解决这个问题。
        };
    }*/
    //正确的代码一：
    /*var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        ;
        (function (i) {//这里的这个i，已经不是外面的那个i变量了。
            oLis [i].onclick = function () {
                alert(i);
            };
        })(i);
    }*/
    //正确代码二：
    /*function fn(i) {
        oLis [i].onclick = function () {
            alert(i);
        };
    }
    var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        fn(i);
    }*/
    /*以上代码中，无论是定义有名的函数还是匿名的函数，其实运行的机制都是一样的，在这里都是为了让里面的变量i不受外面变量i的影响。无论是有名的函数还是匿名的函数，在运行的时候里面的i都会变为一个具体的数值。
     把上面的代码分解一下：
     当第一次循环运行的时候，i的值为0，则实际运行的代码如下：*/
//    ;(function (i) {//这里的这个i，已经不是外面的那个i变量了。
//        oLis [i].onclick = function () {
//            alert(i);
//        };
//    })(0);//因为i第一次是0，那么这里就相当于把0做为实参传给这个要运行的匿名函数，当这个匿名函数运行的时候，实际执行的就是这句代码了：
//    oLis [0].onclick = function () {
//        alert(0);
//    };//alert里已经是一个具体的数值了，第一次是0,依次是1、2、3、4。

    //有名的那个函数和匿名函数的运行过程相同。
    //这个小示例，可以让您加深理解函数的运行过程和闭包的功能作用。更详细深入的掌握听请老师在课堂上的讲解。

/*    关于闭包和作用域
    请听题：请分别说出下面 a b c d的值*/
    function fo(){
        var i=0;
        return function(n){
            return n+i++;
        }
    };

    var f=fo();


    var a = f(15); //value:__________________
    var b = fo()(15); //value:__________________
    var c = fo()(20); //value:__________________
    var d = f(20); //value:__________________

    console.log('a:'+a+';')
    console.log('b:'+b+';')
    console.log('c:'+c+';')
    console.log('d:'+d+';')


    /*分析：
    在fo这个函数里，定义了一个内部方法，这是个闭包方法，它在fo运行的这个作用域里活动。当fo运行时，会将其返回。
    每运行一次，就会创建这样一个方法，并将其返回。
    fo()(15)的意思就是fo先运行，运行后返回一个函数，再在这个返回的函数后边加括号，就是再让这个返回的函数运行。
    后边括号里的15，就是传给里面那个匿名函数的实参，这个函数将15和fo这个作用域里定义的i先累加，然后i再自加1，就是n+i++的意思，所以就是15+0，所以fo()(15)返回的值是15。

    看b和c，函数fo每运行一次，里面的变量i和那个匿名函数就会被创建一次，fo()(15)和fo()(20)是相当于fo分别被运行了两次，创建了两个不同的作用域，
    这两个作用域里的变量或值是不会有任何关系的，并且这两次运行，完成之后这个作用就销毁了。

    a和d是都是在执行f这个函数，f是同一次fo执行时的返回值，
    也就是说，当fo这时候运行的时候，fo这个作用域里定义的这个函数（函数也是数据），被全局变量f给占用了，那么这次fo函数运行产生的这个作用域，就不能被销毁了。
    f第一次运行的时候，返回了15，把这个作用域里的i变成了1，当第二次f再运行的时候，就是20和1相加了，所以是21。当20和1相加之后，i再累加，则i就是就是2了。
    这时候这个作用域还是释放不掉，因为f是全局变量。如果这会写一个f=null，则就能把这个作用域释放掉了。

    所以正确答案是：a是15，b是15，c是20，d是21。*/

</script>
</body>
</html>