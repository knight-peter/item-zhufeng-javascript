<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>预解释</title>
</head>
<body>

<script>
    /*
    * 用var 去声明一个变量的时候，只是被提前声明，不会被赋值，就是只是被预解释，但不是执行等号的这个赋值运算。
    * 而用function去定义变量的时候，不但会被提前声明，还要被初始化一个值。
    * 预解释的代码不会受到return的影响。
    * */


    //1.代码运行之前，先扫描一遍有没有带var关键字的脚本，先去内存里给变量开一个空间。(栈内存)
    // 这会的变量没有值（没有数据），则用undefined来表示。undefined表示不存在的标识（记号）
    //这样的预解释叫声明（declear）

    //2.当代码正常执行的时候，在内存里分配一个空间保存”珠峰培训”这个数据。

    //3.让数据”珠峰培训”和变量a发生关联，就是把”珠峰培训”赋给变量a。这里相当于定义（defined），此后再输出a，才是"珠峰培训"这个字符串呢。

    /*alert(a);//在定义之前就可以输出，但输出的结果是undefined
    var a = "珠峰培训"//在这里用var关键字定义
    alert(a);//在定义之后，才会输出"珠峰培训"*/




    /*
    * function
    * 预定义
    * 在代码执行之前，把所有带function关键字的扫描一遍，然后定义变量，并且给这个函数名赋了值（就是函数体）
    * */
//    fn();//在定义之前执行是可以的
//    function fn(){alert("我可以在定义之前运行");}




     /*var n=9;
     var s='str';
     function fn(){
     alert(n);
     alert(s);
     n=7;
     var n=6;
     };
     fn();//运行这个函数，会输出什么结果?*/
    /*
    第一次很多人以为会输出9，但正确的输出结果是undefined。
    为什么会这样呢？这就涉及到js中的变量预解释和变量作用域的概念了。

    !!!  在同一个作用域里面是按照从上到下的顺序执行js，先声明变量和function（这就是预解释），然后再同一作用域里面从上到下找变量，没找到就到上一级作用域去找。

fn这个方法运行的过程是这样的：
    当它运行的时候，先把里面带var关键字和带function关键字的变量先解释，
    这个方法里有var n=6，那就会先把n这个变量给定义了，
    但后面的赋值动作不做（n=6是个表达式，这个赋值的表达式不能预解释），
    就相当于在fn这个方法里，已经有n这个变量了，但是还未赋值。
    预解释之后才开始按顺序执行，当执行到alert(n)的时候，变量n其实已经定义过了，
    但是还没有赋值，定义而未赋值的变量值就是undefined。


    对第二个alert(s)会输出str这个字符串大家应该没有什么异意。
    在fn这个方法运行的时候，会形成一个自己的私有作用域，
    当用到s这个变量时，先在fn这个变量作用域里找s这个变量，
    如果找不到，则往上一级作用域里找，找到了则以这个级的这个变量为准，
    如果还找不到，则再往上一级作用域里找，一直找到window这个顶级作用域，
    如果还没有，则报一个变量未定义的错误。这样一级一级的往上查找，就形成了一个作用域链。
    而这里的这个s是在上一级作用域里定义并赋值的，所以这里会弹出str。


    当然，在fn方法运行的时候，变量n也是会象变量s那样的方式来查找，
    不过在这一级用域里已经定义了，所以就不会再往上一级作用域里去找了。


    js中的预解释：凡是带var和function关键字的，都会预解释。就是在执行代码之前，先执行


    在fn这个方法里，var n=6这个表达式相当于执行了三步，
    第一步是在脚本执行之前先定义一个变量n，
    第二步和第三步是当脚本执行到这一行的时候，出现一块内存来表示6，然后把6赋值给n，即： var n和n=6;变量的定义是预解释的，但赋值是不预解释的。


    变量作用域：
    当一个函数在运行的时候，就形成了一个自己的私有作用域，这个私有的作用域会开成闭包（封闭的包）。
    预解释是在私用作用域里的预解释。
    在查找变量的时候先找自己的这个作用域里是不是定义了这个变量，自已这个作用域里如果没有，则再往上一级作用域里找。
    一直找到window，如果还找不到，则浏览器就要报错了。


    JS里，window是顶级作用域。
    * */
//    avaScript中的预解释，是种毫无节操的机制 ，根本就不会理会条件，比如下面的例子

//    fn();//9和8是不相等的，但fn这个方法同样预解释了
//    if(9==8){
//        //不管什么条件，这个fn方法都会被预解释的。所以，上面的fn肯定会运行（firefox除外）
//        function fn(){alert('坑爹的预解释')}
//    }
//    再看下一个实例：
//    function fn(){alert('我是全局的fn方法')}

//    function fn2(){//定义一个fn2方法
//        alert(fn);//在这个方法里会弹出fn这个方法的原形，但全局作用域里也定义了一个fn方法
//        fn=3;//当代码运行的到这一行的时候，fn的值会被改变
//        return ;//运行到这一行的时候，方法就退出了
//        function fn(){alert('我是定义在fn2方法里边的')}//但你不要忘了，带function关键字的，也是要预解释的。预解释是一种无节操的机制
//    }
//    fn2();//fn2这个方法运行的时候，会弹出什么结果？
//答案是会弹出在fn2这个方法里面定义的那个fn方法，因为这个方法在fn2这个作用域里被预解释的。预解释的代码不会受到return的影响。


    /*关于重名变量和预解释
    从一道变态的面试题说起：（这里和预解释暂时没关系，和JS里变量定义的机制有关）*/
    function a(x) {    return x * 2;}
    var a;
    alert(a);
    /*你给的答案可能是会输出下面这个var a的值，变量a只是被定义了，没有赋值，所以应该是undefined。虽然上面也定义了一个function类型的a，你可能会认为上面的a会被下面的表达 var a给覆盖了。
    但是输出的结果输出的结果很信人诧异：是function a的内容。这是为什么呢？
    在JavaScript中，使用var语句多次声明一个同名变量是合法的并且也没有什么害处。
    这道面试题，function a(x) {return a+x}，从JS的机制来讲，就是在变量表中有一个变量名字叫做a，并且，它被赋予了初始值，这个初始值值指向堆上的一个地址，这个地址代表一个函数的入口地址
    （这个过程是被预解释的，你即便在定义之前去alert(a)，也是没问题的）。
    虽然没有var a = 0这样显示的赋值，但是从Js Engine的角度来讲，function a(x)表示a这变量，并且这个变量是有指向地址的。
    等到进行到下一行，var a。这里只是一个声明，JS引擎只负责查看变量表中有没有这个a，如果有，那么就不需要做什么了，因为你没有给他赋值的动作。所以，最后看到的a还是function的信息。
     */
</script>
</body>
</html>