<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>02.1.作用域</title>
    <style type="text/css">
        #ul1 li {
            height: 20px;
            width: 100px;
            overflow: hidden;
            background: green;
            margin: 10px;
            position: relative;
        }
    </style>
</head>
<body>
<ul id="ul1">
    <li>11111111</li>
    <li>22222222</li>
    <li>33333333</li>
    <li>444444444</li>
    <li>55555555</li>
</ul>
<script>
    /*数据也是要有隐私的---我的地盘我做主
     JS中没有代码块----使用函数运行的机制创建
     变量预解释是在各自的作用域里的预解释*/
    /*全局变量是window的属性
     Window的属性也可以看做全局变量
     一个对象的属性，也可以看这以这个对象为作用域下的变量– with语句
     那看代码：function fn(){var a=9};
     fn函数里的a是谁的属性呢？
     */
    function fn() {
        var n = 99;
    }
    console.log(fn())
    /*活动对象:===========================================================================================================
     函数的运行是个有生命周期的内存地址
     或者说：函数运行时，会创建一个内存地址，当此函数运行结束时，此内存地址又会销毁。这个地址，我们无法保存，它是灵活的、活动的、有生命周期的。
     函数里的变量，就在这个内存里创建，我们可以把这个内存当成一个对象，那函数里的变量就是这个对象的属性
     严重理解函数的定义和函数的运行*/


    //    作用域和闭包=========================================================================================================


    /*可以简单的理解为作用域就是闭包
     闭包是机制，而不是形式，不是概念
     不同的教材上对闭包解释不同
     《高程3》第192页小结中的解释
     《权威指南》182页中对闭包的解释
     使用闭包，还不如直接说使用一个作用域。实在人不用闭包这个概念！（程序员的自我修养—不吓人）
     */


    //  闭包用在什么场合========================================================================================================

    /*保持个性--保护自己
    同时还能和它人友好沟通--留好接口（通道）--参数
    作用域在定义的时候就确定了*/

    //应用在异步函数中
    /*    再看一个具体的应用实例：
     有如下html代码，要求：点击下面的li，会弹出对应的索引号。
     <ul>
     <li>列表一</li>
     <li>列表二</li>
     <li>列表三</li>
     <li>列表四</li>
     <li>列表五</li>
     </ul>
     */


    //很多人给出了如下错误的代码（点击li时弹出的是5）：
    var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        oLis [i].onclick = function () {//注意：这里的这个匿名方法，在循环运行的时候这个匿名方法本身并不运行，当点击某个li的时候，这个方法才运行呢。
            //事件绑定相当于做计划，当点击的时候才相当于执行计划，请参考第一天教材的事件绑定部分的描述
            alert(i);//这里的这个i不是在这个匿名方法里定义的，而是上一级作用域里定义的。(本作用域里面没有i的定义，只能顺着作用域链到上一级作用域去找)当这句代码运行的时候，循环早已经结束，并且i已经等于oLis.length了。
            //            这里的问题出在这个方法里用到的是上一级作用域里定义的变量，如果要解决这个问题，要把变量储存到自己独立的定义域里面
        };
    }
    //正确的代码一：
    /*var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        ;(function (i) {//这里的这个i，已经不是外面的那个i变量了。 形参
            oLis [i].onclick = function () {
                alert(i);
            };
        })(i);//实参
    }*/

    //正确代码二：
    /*function fn(i) {
        oLis [i].onclick = function () {
            alert(i);
        };
    }
    var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        fn(i);
    }*/
    //正确代码三（闭包：函数里面套函数）
    /*var oLis = document.getElementsByTagName('li');
    for (var i = 0; i < oLis.length; i++) {
        ;(function (i) {//这里的这个i，已经不是外面的那个i变量了。
            oLis [i].onclick = function (n) {
                return function () {
                    alert(n + 1)
                }
            };
        })(i);
    }*/

    /*以上代码中，无论是定义有名的函数还是匿名的函数，其实运行的机制都是一样的，在这里都是为了让里面的变量i不受外面变量i的影响。无论是有名的函数还是匿名的函数，在运行的时候里面的i都会变为一个具体的数值。
     把上面的代码分解一下：
     当第一次循环运行的时候，i的值为0，则实际运行的代码如下：*/
    //    ;(function (i) {//这里的这个i，已经不是外面的那个i变量了。
    //        oLis [i].onclick = function () {
    //            alert(i);
    //        };
    //    })(0);//因为i第一次是0，那么这里就相当于把0做为实参传给这个要运行的匿名函数，当这个匿名函数运行的时候，实际执行的就是这句代码了：
    //    oLis [0].onclick = function () {
    //        alert(0);
    //    };//alert里已经是一个具体的数值了，第一次是0,依次是1、2、3、4。

    //有名的那个函数和匿名函数的运行过程相同。
    //这个小示例，可以让您加深理解函数的运行过程和闭包的功能作用。更详细深入的掌握听请老师在课堂上的讲解。

</script>
</body>
</html>