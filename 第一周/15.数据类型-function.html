<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数据类型-function</title>
</head>
<body id="bodyEle">

<script type="text/javascript">
//    function:函数数据类型、相当于一个方法或者一个功能
    //定义一个函数的步骤
    //1、开辟一个新的空间地址xxxfff111
    //2、把函数体中的js代码当作字符串存到空间里面（一个函数如果只是定义了，并没有执行的话，没有任何的意义）
    //3、再把函数体存储的空间地址给我们的函数名
    /*function fn(){
        //函数体
        //一个计划，一个功能或者一个方法实现的步骤
        alert("欢迎大家来珠峰培训");

    }
    fn();//函数名+(); 执行这个函数*/
    //首先会形成一个自己的私有地盘
    //然后把定义的时候，存在空间的js代码字符串当作js代码执行
    /*function 约会(){
        1.准备钱
        2.制定路线(先去长城,欢乐谷,国家大剧院,梅州东坡酒楼,电影院,把女朋友送回家)
        3.打电话约
    }
    约会();*/
    function sum(){
        var num=1;
        num+=3;
        num*=5;
        console.log(num);
    }
    sum();
    sum();
    //js中function的一个特别大的作用（函数封装）：
    //将实现一个功能的代码进行封装，以后如果用到了这个功能，代码没有必要再重新写了，只需要执行这个方法就好了。


    //第一次升级：形参（可以理解为一个变量）（多态一个功能的多种形态，通过参数的不同实现不同的功能）
    //作用：实现一个功能，发现部分原材料没有，在制定计划的时候我们没有办法获取，我们就把需要的原材料定义在我们的形参上，在执行的几乎的时候，把原材料提供了就好了。
    //定义了一个形参变量，执行的时候没有传递值，那么默认值是undefined
    function sum2(num1,num2){
        var total=0;
        if(typeof num1!="undefined"){
            total+=num1;
        }
        if(typeof num2!="undefined"){
            total+=num2;
        }

//        var total=num1+num2;
        console.log("sum2:"+total);
    }
    sum2(100,200);
    sum2(2,2);
    sum2(100);//100+undefined,输出结果为nan
    sum2();//输出结果为0
    sum2(100,200,300);//输出结果为300，300的形参为undefined,100+200为300





    //arguments:是函数内置接受参数的机制
    //内置：天生在自带的，不管你是否传递了参数，也不管是否写形参了，arguments一直的存在
    //arguments也是一个类数组（有数字作为索引，索引从0开始代表第几个传递的参数，还有一个length的属性代表传递了多少个参数）
    //arguments获取其中的某一个只能用arguments[索引]，不能用.item()
    //callee:arguments.callee代表的就是当前函数的本身
    /*function fn(){
        var total=0;
        for(var i=0;i<arguments.length;i++){
            var cur=arguments[i];
            cur=Number(cur);
            if(!isNaN(cur)){
                 total+=cur;
            }
        }
        console.log("total:"+total);

        /!*console.dir(arguments);
        console.log(arguments[0]);
        console.log(arguments[1]);
        console.log(arguments.length);*!/
    }
        fn(1,2,3);
        fn(1,2,"3");*/
//        console.log(total);//total is not defined

//        函数执行的时候会形成一个私有的地盘（函数里面定义的变量，在外面不能直接使用）
    //闭包：函数执行的时候会形成一个新的私有的作用域，来保护里面的变量不受外界的干扰，我们把这种机制叫做闭包。

//    fn(123,234);
//    fn();
//    fn(213);
//    fn(1,2,3,4,5,6,7,8,9,10);
    //console.dir比console.log在控制台输出的详细一些


function fn() {
    var total = 0;
    for (var i = 0; i < arguments.length; i++) {
        var cur = arguments[i];
        cur = Number(cur);
        if (!isNaN(cur)) {
            total += cur;
        }
    }
    return total;
    //return后面的代码不再执行
    /*total+=100;
    console.log(total);*/
//    console.log("total:" + total);
}
/*console.log(fn(1, 2, "3"));//通常不这么做*/

    var total=fn(1,2,"3");//把函数执行完成的整体返回值赋值给外面的total这个变量
    total*=3;
    console.log(total);

    var n=fn(100,200);

//    外面想用什么，在函数里面直接的return返回就可以了，函数执行完成的整体就是这个值

//    如果我们没有写return的话（或者return），默认的返回结果是undefined

//    在函数体中，return后面的代码不再执行：
//    return的第二个作用，控制函数体中的代码执行到指定行就结束

    //上面的都是实名函数，还有匿名函数
    //匿名函数表达式：把一个匿名函数的定义部分当一个值赋值给一个变量或者一个元素的事件
    /*var fn=function(){

    }*/

    /*var oBody=document.getElementById("bodyEle");
    oBody.onclick=function(){

    }*/

    //自执行函数：定义和执行一起完成了
    (function(){

    })();
    ~function(){}();
    !function(){}();
    +function(){}();
    -function(){}();

</script>
</body>
</html>